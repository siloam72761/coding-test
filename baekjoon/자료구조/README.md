# 📌 백준 9012 - 괄호

## 🔗 링크  
[문제 링크](https://www.acmicpc.net/problem/9012)

---

## 📋 문제 설명  
- 괄호로 이루어진 문자열이 주어졌을 때, 올바른 괄호 문자열(VPS)인지 판단한다.  
- 여는 괄호와 닫는 괄호의 짝이 맞고, 올바르게 닫히는 구조여야 한다.  

---

## 🧠 알고리즘 분류  
- 스택

---

## ✅ 핵심 포인트 정리  
- stack을 이용해서 '(' 기준으로 비교한다.  
- 닫는 괄호 `')'`는 스택에 '('이 있으면 pop하면서 서로 제거한다.  
- 스택이 비었는데 닫는 괄호가 남아있으면 "NO"  
- 문자열 끝까지 돌았을 때 스택이 비어 있어야 "YES"

---

## 🗒️ 배운 점 & 느낀 점  
- 전에는 Java 버전으로 풀어봤었는데 Python이 코드가 훨씬 간결하다.  
- `return "YES" if not stack else "NO"` 같은 조건부 표현식을 이용하여 코드 훨씬 간결하게 쓸 수 있다.  
- 입력값 여러 개를 리스트로 저장해서 입력받는 연습에 도움이 된다.

---

## ⏱️ 시간복잡도 분석  
- 각 테스트 케이스에 대해 괄호 문자열을 한 번씩 순회: O(N)  

---

# 📌 백준 2493 - 탑

## 🔗 링크  
[문제 링크](https://www.acmicpc.net/problem/2493)

---

## 📋 문제 설명  
- 왼쪽부터 차례대로 탑이 있고, 각 탑은 레이저 신호를 왼쪽으로 보낸다.  
- 각 탑은 자신보다 왼쪽에 있으면서 **더 높은 탑**이 있다면 그 탑이 신호를 수신한다.  
- 각 탑이 **수신하게 되는 탑의 번호(인덱스 + 1)**를 출력한다.  
- 수신할 수 있는 탑이 없다면 0을 출력한다.

---

## 🧠 알고리즘 분류  
- 자료구조  
- 스택

---

## ✅ 핵심 포인트 정리  
- **오른쪽 → 왼쪽** 방향으로 비교해야 하므로 **역순 반복** 필요  
- 스택을 이용하여 왼쪽에 있는 **자신보다 높은 탑 중 가장 가까운 탑**만 남긴다  
- 스택에는 `(인덱스, 높이)` 형식으로 저장해두고,  
  더 낮은 탑은 스택에서 제거하며 최소한으로 유지한다.

---

## 🗒️ 배운 점 & 느낀 점  
- 처음에 짠 코드는 이중 반복문으로 O(N^2)로 시간 초과를 발생하였다.  
- 시간 제한 1.5초면 O(N log N)까지만 적합하다.  
- 단순 이중 반복문(O(N^2))은 시간 초과 발생 → 스택으로 O(N) 구현  
- 필요 없는 값(낮은 탑)은 **스택에서 제거(pop)** 하며  
  남은 값만으로 신호를 수신할 수 있게 하는 방식에 대해 새로 배웠다.  

---

## ⏱️ 시간복잡도 분석  
- 각 탑은 스택에 **한 번 push, 한 번 pop** → 최대 2N번 연산  
- 따라서 전체 시간복잡도는 **O(N)**  

---

# 📌 문제 이름 (백준 2164 - 카드2)

## 🔗 링크  
[문제 링크](https://www.acmicpc.net/problem/2164)

---

## 📋 문제 설명  
- N장의 카드를 1장이 남을 때 까지 다음을 진행한다.  
- 제일 위에 카드를 바닥에 버린다.  
- 그 다음, 제일 위에 있는 카드를 제일 아래로 옮긴다.

---

## 🧠 알고리즘 분류  
- 자료구조, 큐

---

## ✅ 핵심 포인트 정리  
- 카드의 순서는 서로 이어져있기 때문에 이에 적합한 'Deque'를 사용한다.

---

## 🗒️ 배운 점 & 느낀 점  
- 입력이 500,000개 정도로 주어지면, O(logN)으로 풀 수 있다는걸 암시하는 것일 수도 있다.  
- 처음에는 O(N)으로 풀었지만 수학적 규칙을 발견하면 O(log N)으로 풀 수 있다.  

---

## ⏱️ 시간복잡도 분석  
- 단순히 큐로 풀 경우 O(N)이 걸린다.  
- 수학적 풀이로 풀 경우 O(log N)까지 가능하다.

---
# 📌 백준 10815 - 숫자 카드

## 🔗 링크  
[문제 링크](https://www.acmicpc.net/problem/10815)

---

## 📋 문제 설명  
- 숫자 카드 N장을 가지고 있다.  
- 정수 M개가 주어졌을 때, 이 수가 숫자 카드에 있는지 확인한다.  
- 있으면 1, 없으면 0을 출력한다.  

---

## 🧠 알고리즘 분류  
- 자료구조   
- 해시(Set)

---

## ✅ 핵심 포인트 정리  
- 수의 존재 여부만 판단하는 문제  
- **Set 사용:** 평균적으로 빠르게( O(1) ) 확인 가능  

---

## 🗒️ 배운 점 & 느낀 점  
- 'set()'를 이용하면 빠른 연산으로 구현이 가능하다.
- 많은 쿼리에 빠른 응답 필요 시에 적합하다.
- 이분 탐색으로도 구현이 가능한데, 속도는 더 느리다. 
- 메모리를 아끼거나, 정렬된 데이터 기반 일 때 적합하다.
---

## ⏱️ 시간복잡도 분석  
- 숫자 카드 저장: O(N)  
- 존재 여부 확인 (M번): O(1) * M → O(M)  
- 전체: O(N + M)

---
# 📌 백준 1406 - 에디터

## 🔗 링크  
[문제 링크](https://www.acmicpc.net/problem/1406)

---

## 📋 문제 설명  
- 한 줄로 된 문자열이 주어지고, 커서를 기준으로 편집 명령을 수행한다.  
- 명령은 L(왼쪽 이동), D(오른쪽 이동), B(왼쪽 문자 삭제), P(왼쪽에 문자 추가)로 구성된다.  
- 모든 명령 수행 후 완성된 문자열을 출력한다.

---

## 🧠 알고리즘 분류  
- 자료구조  
- 스택  
---

## ✅ 핵심 포인트 정리  
- 커서를 기준으로 왼쪽과 오른쪽 스택을 나눠 처리하면 효율적으로 구현할 수 있다.  
- 각 명령을 O(1) 시간에 처리 가능하게 하려면, 일반 문자열보다 스택을 사용하는 것이 적합하다.  
- 최종 출력 시에는 왼쪽 스택 + 오른쪽 스택(reversed) 순서로 문자열을 합친다.

---

## 🗒️ 배운 점 & 느낀 점  
- 일반 문자열에서 insert/delete 연산을 직접 수행하면 시간 초과가 발생할 수 있다.  
- 스택 두 개로 커서를 구현하는 방식에 대해서 처음 고민하게 되었다.

---

## ⏱️ 시간복잡도 분석  
- 명령어 처리: O(1) (최대 N번)  
- 최종 문자열 출력: O(K) (K는 전체 문자열 길이)  
- 전체 시간복잡도: **O(N + K)**

---
# 📌 백준 10799 - 쇠막대기

## 🔗 링크  
[문제 링크](https://www.acmicpc.net/problem/10799)

---

## 📋 문제 설명  
- 레이저와 쇠막대기를 표현한 괄호 문자열이 주어진다.  
- 쇠막대기는 '('로 시작해서 ')'로 끝난다.  
- 레이저는 '()'로 표현된다.  
- 레이저가 쇠막대기를 자를 때 생기는 **조각의 총 개수**를 출력하는 문제이다.

---

## 🧠 알고리즘 분류  
- 자료구조  
- 스택  

---

## ✅ 핵심 포인트 정리  
- 여는 괄호 `'('`가 나오면 스택에 추가.  
- 닫는 괄호 `')'`일 때,  
  - 직전 문자가 `'('`이면 레이저이므로 스택에서 하나를 빼고, 스택 길이만큼 조각 추가.  
  - 직전 문자가 `')'`이면 막대기 끝이므로 스택에서 하나를 빼고 조각 1개 추가.  
- 레이저가 나올 때마다 **현재 열려있는 막대기 수**만큼 조각이 생긴다.

---

## 🗒️ 배운 점 & 느낀 점  
- 문제를 정확하게 이해하고 조건문을 정확하게 짜는게 핵심이다.
- 레이저로 짜를 때 막대기만큼 증가하고, 1개씩 더 추가로 생기므로 마지막 닫는 괄호에서 +1만큼 증가시킨다.

---

## ⏱️ 시간복잡도 분석  
- 문자열 길이 N에 대해 한 번씩 순회하며 처리 → **O(N)**
