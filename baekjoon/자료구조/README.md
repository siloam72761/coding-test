# 📌 백준 9012 - 괄호

## 🔗 링크  
[문제 링크](https://www.acmicpc.net/problem/9012)

---

## 📋 문제 설명  
- 괄호로 이루어진 문자열이 주어졌을 때, 올바른 괄호 문자열(VPS)인지 판단한다.  
- 여는 괄호와 닫는 괄호의 짝이 맞고, 올바르게 닫히는 구조여야 한다.  

---

## 🧠 알고리즘 분류  
- 스택

---

## ✅ 핵심 포인트 정리  
- stack을 이용해서 '(' 기준으로 비교한다.  
- 닫는 괄호 `')'`는 스택에 '('이 있으면 pop하면서 서로 제거한다.  
- 스택이 비었는데 닫는 괄호가 남아있으면 "NO"  
- 문자열 끝까지 돌았을 때 스택이 비어 있어야 "YES"

---

## 🗒️ 배운 점 & 느낀 점  
- 전에는 Java 버전으로 풀어봤었는데 Python이 코드가 훨씬 간결하다.  
- `return "YES" if not stack else "NO"` 같은 조건부 표현식을 이용하여 코드 훨씬 간결하게 쓸 수 있다.  
- 입력값 여러 개를 리스트로 저장해서 입력받는 연습에 도움이 된다.

---

## ⏱️ 시간복잡도 분석  
- 각 테스트 케이스에 대해 괄호 문자열을 한 번씩 순회: O(N)  

---

# 📌 백준 2493 - 탑

## 🔗 링크  
[문제 링크](https://www.acmicpc.net/problem/2493)

---

## 📋 문제 설명  
- 왼쪽부터 차례대로 탑이 있고, 각 탑은 레이저 신호를 왼쪽으로 보낸다.  
- 각 탑은 자신보다 왼쪽에 있으면서 **더 높은 탑**이 있다면 그 탑이 신호를 수신한다.  
- 각 탑이 **수신하게 되는 탑의 번호(인덱스 + 1)**를 출력한다.  
- 수신할 수 있는 탑이 없다면 0을 출력한다.

---

## 🧠 알고리즘 분류  
- 자료구조  
- 스택

---

## ✅ 핵심 포인트 정리  
- **오른쪽 → 왼쪽** 방향으로 비교해야 하므로 **역순 반복** 필요  
- 스택을 이용하여 왼쪽에 있는 **자신보다 높은 탑 중 가장 가까운 탑**만 남긴다  
- 스택에는 `(인덱스, 높이)` 형식으로 저장해두고,  
  더 낮은 탑은 스택에서 제거하며 최소한으로 유지한다.

---

## 🗒️ 배운 점 & 느낀 점  
- 처음에 짠 코드는 이중 반복문으로 O(N^2)로 시간 초과를 발생하였다.  
- 시간 제한 1.5초면 O(N log N)까지만 적합하다.  
- 단순 이중 반복문(O(N^2))은 시간 초과 발생 → 스택으로 O(N) 구현  
- 필요 없는 값(낮은 탑)은 **스택에서 제거(pop)** 하며  
  남은 값만으로 신호를 수신할 수 있게 하는 방식에 대해 새로 배웠다.  

---

## ⏱️ 시간복잡도 분석  
- 각 탑은 스택에 **한 번 push, 한 번 pop** → 최대 2N번 연산  
- 따라서 전체 시간복잡도는 **O(N)**  

---

# 📌 문제 이름 (백준 2164 - 카드2)

## 🔗 링크  
[문제 링크](https://www.acmicpc.net/problem/2164)

---

## 📋 문제 설명  
- N장의 카드를 1장이 남을 때 까지 다음을 진행한다.  
- 제일 위에 카드를 바닥에 버린다.  
- 그 다음, 제일 위에 있는 카드를 제일 아래로 옮긴다.

---

## 🧠 알고리즘 분류  
- 자료구조, 큐

---

## ✅ 핵심 포인트 정리  
- 카드의 순서는 서로 이어져있기 때문에 이에 적합한 'Deque'를 사용한다.

---

## 🗒️ 배운 점 & 느낀 점  
- 입력이 500,000개 정도로 주어지면, O(logN)으로 풀 수 있다는걸 암시하는 것일 수도 있다.  
- 처음에는 O(N)으로 풀었지만 수학적 규칙을 발견하면 O(log N)으로 풀 수 있다.  

---

## ⏱️ 시간복잡도 분석  
- 단순히 큐로 풀 경우 O(N)이 걸린다.  
- 수학적 풀이로 풀 경우 O(log N)까지 가능하다.
