# 🧩 백준 15649 - N과 M (1)

## 📌 문제 설명
1부터 N까지 자연수 중에서 **중복 없이** M개를 고른 **순열**을 모두 출력하는 문제이다.  
(순서가 다르면 다른 수열로 간주한다.)

## 📂 알고리즘 분류
- 백트래킹
- DFS

## 🔑 핵심 포인트 정리
- 순서를 고려해야 하므로 `(1,2)`와 `(2,1)`은 다른 경우로 취급한다.
- 이미 사용한 수는 다시 사용할 수 없으므로 `visited` 배열로 중복을 방지한다.
- DFS를 이용해 깊이가 `M`이 되면 출력한다.

## ✨ 배운점 & 느낀점
- **백트래킹의 기본 뼈대**를 연습할 수 있었다.
- 방문 처리를 하고, 다시 원상복구하는(backtracking) 과정을 통해  
  "모든 경우의 수"를 탐색하는 감각을 익혔다.
- `visited` 배열이 꼭 필요한 이유를 명확히 이해했다.

## ⏱ 시간 복잡도
- 경우의 수: `P(N, M) = N! / (N-M)!`
- DFS 호출 트리의 크기와 동일 → 최악의 경우 `O(N!)`에 가깝다.

---

# 🧩 백준 15650 - N과 M (2)

## 📌 문제 설명
1부터 N까지 자연수 중에서 **중복 없이** M개를 고른 **조합**을 모두 출력하는 문제이다.  
(순서가 다른 경우라도 같은 집합이면 같은 경우로 취급한다. 즉 `(1,2)`와 `(2,1)`은 동일하다.)

## 📂 알고리즘 분류
- 백트래킹
- DFS

## 🔑 핵심 포인트 정리
- 조합은 순서가 중요하지 않으므로, **이미 선택한 수보다 큰 수만 탐색**해야 한다.
- 따라서 `start` 매개변수를 사용하여 탐색 범위를 제한한다.
- `visited` 배열 없이 구현 가능하다.

## ✨ 배운점 & 느낀점
- 순열(15649)과 달리 **조합은 `visited` 없이도 구현 가능**하다는 점을 알게 되었다.
- `for`문의 시작 인자를 `start`로 설정하면 자연스럽게 **중복 제거**가 된다.
- 순열과 조합의 **핵심 차이**를 코드로 비교하며 이해할 수 있었다.

## ⏱ 시간 복잡도
- 경우의 수: `C(N, M) = N! / (M! * (N-M)!)`
- DFS 호출 횟수와 동일 → 조합의 크기에 비례한다.

---
# 🧩 백준 15651 - N과 M (3)

## 📌 문제 설명
1부터 N까지 자연수 중에서 **중복 허용**하여 M개를 고른 **수열**을 모두 출력하는 문제이다.  
(순서가 다르면 다른 경우로 취급한다.)

## 📂 알고리즘 분류
- 백트래킹
- DFS

## 🔑 핵심 포인트 정리
- 중복이 가능하므로 **visited 배열이 필요 없다.**
- 단순히 매번 1부터 N까지 모든 수를 선택할 수 있도록 탐색하면 된다.
- 깊이가 `M`이 되면 현재 수열을 출력한다.

## ✨ 배운점 & 느낀점
- 중복 허용이 가능해지면 문제 구조가 훨씬 단순해진다.
- `visited`의 역할이 언제 필요한지 확실히 구분할 수 있게 되었다.  
  - **15649** → 중복 불가 → `visited` 필요  
  - **15650** → 중복 불가 + 오름차순 → `start` 활용  
  - **15651** → 중복 허용 → `visited` 불필요


## ⏱ 시간 복잡도
- 경우의 수: `N^M` (각 자리에 N개를 중복해서 고를 수 있음)
- 따라서 시간 복잡도는 `O(M * N^M)`이다.
