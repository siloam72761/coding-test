# 🧭 백준 2178 - 미로 탐색

## 📌 문제 설명
N×M 크기의 미로에서 1은 이동 가능한 칸, 0은 이동할 수 없는 벽입니다.  

(0, 0)에서 시작하여 (N-1, M-1)까지 **최단 거리**로 이동할 때, 지나야 하는 칸의 개수를 구하는 문제입니다.

[백준 문제 링크](https://www.acmicpc.net/problem/2178)

---

## ✅ 입력 형식
- 첫째 줄에 N(세로), M(가로)이 주어짐 (2 ≤ N, M ≤ 100)
- 다음 N개의 줄에 M개의 숫자로 미로가 주어짐 (0 또는 1)

## ✅ 출력 형식
- 시작점에서 도착점까지의 **최단 경로의 칸 수**

---

## 💡 풀이 핵심 아이디어
- **BFS(너비 우선 탐색)** 사용
- (0,0)에서 시작하여 이동 가능한 칸을 차례대로 큐에 넣고 거리 갱신
- 방문한 칸은 `graph[nx][ny] = graph[x][y] + 1` 로 거리 누적
- 도착 지점 `(N-1, M-1)`에 도달하면 그 칸의 값이 최단 거리

---

## 🧠 배운 점
- BFS 알고리즘의 이해
- `queue`를 이용한 탐색 순서 제어
- 2차원 리스트에서 상하좌우 탐색 방법 (dx/dy 배열 활용)

---

# 📌 백준 1012 - 유기농 배추

## 🔗 링크  
[문제 링크](https://www.acmicpc.net/problem/1012)

---

## 📋 문제 설명  
- M x N 크기의 배추밭에 배추가 심어져 있음  
- 인접한 배추들이 모여있는 영역마다 **하나의 지렁이**가 필요함  
- 서로 인접한 배추들은 하나의 군집으로 간주  
- 필요한 지렁이 수(= 배추 군집 수)를 출력

---

## 🧠 알고리즘 분류  
- 그래프 탐색  
- DFS / BFS  
- 연결 요소 찾기  

---

## ✅ 핵심 포인트 정리  
- 인접한 배추들을 하나의 **연결 요소**로 보고, 그 수를 세는 문제  
- DFS 혹은 BFS로 군집을 탐색하면서 방문 체크  
- 2차원 배열에서 **상하좌우** 방향 탐색 필요  

---

## 🗒️ 배운 점 & 느낀 점  
- 단순한 그래프 탐색이지만, 2차원 배열 형태에서는 구현에 주의가 필요  

---

## ⏱️ 시간복잡도 분석  
- 각 배추마다 최대 한 번만 DFS 호출됨 → O(K)  
- K는 최대 2500 (배추 개수) 

---

# 📌 백준 2667 - 단지번호붙이기

## 🔗 링크  
[문제 링크](https://www.acmicpc.net/problem/2667)

---

## 📋 문제 설명  
- N×N 크기의 지도에 집이 존재(1)하거나 존재하지 않음(0)  
- 연결된 집들을 하나의 **단지**로 묶어 번호를 붙임  
- 단지의 총 개수와 각 단지 내 집의 수를 출력  

---

## 🧠 알고리즘 분류  
- DFS / BFS  

---

## ✅ 핵심 포인트 정리  
- 집이 있는 칸(1)에서 시작해 상하좌우로 연결된 집을 DFS/BFS로 탐색  
- 탐색이 끝날 때마다 단지의 크기를 기록  
- 결과는 단지 개수와 단지별 집 수(오름차순 정렬)  

---

## 🗒️ 배운 점 & 느낀 점  
- DFS를 통해 2차원 배열에서 연결 요소를 찾는 기본 패턴을 익힘  
- 인덱스 좌표 `(y, x)` 관리가 중요하다는 점을 다시 확인함  
- BFS/DFS 방식 모두 동일하게 적용 가능  

---

## ⏱️ 시간복잡도 분석  
- 모든 칸을 최대 한 번 방문 → O(N²)  
