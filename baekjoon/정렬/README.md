# 📌 백준 1181 - 단어 정렬

## 🔗 링크
[문제 링크](https://www.acmicpc.net/problem/1181)

---

## 📋 문제 설명
- 알파벳 소문자로 이루어진 N개의 단어를 정렬한다.
- 길이가 짧은 것부터, 같다면 사전 순으로 정렬한다.
- 단, 중복된 단어는 하나만 남기고 제거한다.

---

## 🧠 알고리즘 분류
- 정렬

---

## ✅ 핵심 포인트 정리
- `input().strip()`을 이용해서 N개의 문자열을 한 줄씩 입력받는다.
- `lambda`를 이용해서 길이로 먼저 정렬한 뒤, 길이가 같다면 사전 순으로 정렬한다.

---

## 🗒️ 배운 점 & 느낀 점
- 리스트에서 중복을 제거할 때 `if x not in list:`처럼 확인하면 **O(N²)** 의 시간이 걸릴 수 있다.
- `set()`을 사용하면 **O(N)** 에 중복을 제거할 수 있고, 이후 정렬까지 포함해도 전체 시간 복잡도는 **O(N log N)** 이다.

---

## ⏱️ 시간복잡도 분석
- 중복 체크를 리스트로 할 경우: **O(N²)**
- `set()`으로 중복 제거 후 정렬 시: **O(N log N)** ← 개선된 코드

---

# 🧩 백준 10814 - 나이순 정렬

## 🔗 링크
[문제 링크](https://www.acmicpc.net/problem/10814)

---

## 📋 문제 설명
- 나이와 이름이 주어진 회원 목록을 정렬한다.
- 나이를 오름차순으로 정렬하고, 나이가 같다면 **입력 순서**를 유지한다.

---

## 🧠 알고리즘 분류
- 정렬

---

## ✅ 핵심 포인트 정리
- 나이를 기준으로 정렬해야 하므로, `int` 형으로 변환하여 튜플로 저장한다.
- 파이썬의 기본 정렬은 **stable sort**이므로 입력 순서가 유지된다.

---

## 🗒️ 배운 점 & 느낀 점
- 리스트 내에서 각 항목의 자료형을 변환하는 패턴에 익숙해졌다.
- `age`가 문자열이었는데 `int`로 변환해 정렬이 정확히 되도록 처리했다.

---

## ⏱️ 시간복잡도 분석
- N명의 데이터를 정렬 → **O(N log N)**

---
# 📌 백준 11651 - 좌표 정렬하기 2

## 🔗 링크  
[문제 링크](https://www.acmicpc.net/problem/11651)

---

## 📋 문제 설명  
- 2차원 평면 위의 점 N개가 주어진다.  
- 좌표를 **y좌표가 증가하는 순**으로, y좌표가 같으면 **x좌표가 증가하는 순**으로 정렬해서 출력한다.

---

## 🧠 알고리즘 분류  
- 정렬

---

## ✅ 핵심 포인트 정리  
- `(x, y)` 형태의 좌표를 `tuple`로 입력받는다.  
- `sort()`의 `key`로 `lambda x: (y, x)` 형태인 `lambda p: (p[1], p[0])`를 사용하여 정렬한다.

---

## 🗒️ 배운 점 & 느낀 점  
- 다중 조건으로 정렬할 때는 `lambda`를 활용한 정렬 키를 설정하는 방법이 유용하다.  
- 문제에서 요구하는 순서를 정확히 구현하기 위해, 조건의 우선순서를 잘 파악하는 것이 중요하다.

---

## ⏱️ 시간복잡도 분석  
- 정렬의 시간 복잡도는 **O(N log N)**  

---
# 📌 백준 10989 - 수 정렬하기 3

## 🔗 링크  
[문제 링크](https://www.acmicpc.net/problem/10989)

---

## 📋 문제 설명  
- N개의 수가 주어진다.  
- 이 수를 **오름차순으로 정렬**하여 한 줄에 하나씩 출력하는 문제이다.  
- 수의 개수는 최대 10,000,000개이며, 수의 범위는 1 ~ 10,000이다.

---

## 🧠 알고리즘 분류  
- 정렬  
- 카운팅 정렬  

---

## ✅ 핵심 포인트 정리  
- 수의 **범위가 작고**(1~10,000), 개수가 많기 때문에 **카운팅 정렬**이 적합  
- 입력이 매우 많으므로 `sys.stdin.readline()`을 이용해 입력 속도 향상  
- `count[i]`는 숫자 i가 등장한 횟수를 의미하며, 정렬 시 해당 숫자를 등장 횟수만큼 출력  

---

## 🗒️ 배운 점 & 느낀 점  
- 입력 범위와 데이터 크기를 고려해 정렬 방식을 선택하는 것이 중요하다.  
- 카운팅 정렬에 대한 개념과 동작 원리에 대해서 알게 되었다.
- 수의 범위는 10,000보다 작거나 같은 자연수이므로, count 배열의 최대 크기를 10001로 정의해준다. (메모리 초과 방지) 

---

## ⏱️ 시간복잡도 분석  
- 입력 처리: O(N)  
- 카운팅 정렬 정리 및 출력: O(K + N), (K는 값의 범위)  
- 따라서 전체 시간복잡도는 **O(N)**  

