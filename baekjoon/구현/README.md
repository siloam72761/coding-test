# 📌 문제: 로봇 청소기 (백준 14503)

- 구현 유형 시뮬레이션 문제  
- 청소 로봇의 동작 로직을 그대로 구현하는 문제

## ✅ 문제 설명

방의 상태와 로봇의 초기 위치가 주어졌을 때, 로봇이 청소할 수 있는 칸의 수를 출력하는 문제입니다.

- 방향: 북(0), 동(1), 남(2), 서(3)  
- 벽은 1, 청소 가능한 칸은 0

### ✅ 주요 개념

- 방향 처리: `dx`, `dy`  
- 범위 검사: `0 <= x < N`, `0 <= y < M`


---

# 📌 백준 2941 - 크로아티아 알파벳

## 🔗 링크  
[문제 링크](https://www.acmicpc.net/problem/2941)

---

## 📋 문제 설명  
- 알파벳 소문자로 이루어진 단어가 주어진다.  
- 크로아티아 알파벳은 특정 조합들을 하나의 문자로 본다.  
- 총 몇 개의 문자가 있는지 세어야 한다.

---

## 🧠 알고리즘 분류  
- 문자열  
- 구현  

---

## ✅ 핵심 포인트 정리  
- 크로아티아 알파벳 조합은 총 8개: `c=`, `c-`, `dz=`, `d-`, `lj`, `nj`, `s=`, `z=`  
- 가장 긴 조합인 `dz=`를 먼저 처리해야 한다.  
- 슬라이싱과 조건문을 통해 하나씩 탐색하면서 조합을 센다.

---

## 🗒️ 배운 점 & 느낀 점  
- 슬라이싱을 통해 문자열 내 특정 길이 조합을 검사할 수 있다.  
- 인덱스를 직접 이동시키며 탐색하는 방식은 문자열 구현에서 자주 쓰인다.  
- 조건 순서를 잘 정하는 것이 중요 (예: `dz=`를 먼저 체크)

---

## ⏱️ 시간복잡도 분석  
- 문자열 길이 N에 대해 선형 탐색  
- 전체 시간복잡도는 **O(N)**

---
# 📌 백준 1157 - 단어 공부

## 🔗 링크  
[문제 링크](https://www.acmicpc.net/problem/1157)

---

## 📋 문제 설명  
- 알파벳 대소문자로 이루어진 단어가 주어진다.  
- 가장 많이 사용된 알파벳을 대문자로 출력한다.  
- 여러 개라면 `?`를 출력한다.

---

## 🧠 알고리즘 분류  
- 문자열  
- 구현  
- 해시 (Counter 등)

---

## ✅ 핵심 포인트 정리  
- 대소문자 구분이 없으므로 `.upper()`로 통일  
- `collections.Counter`로 빈도 수 세기  
- 최댓값이 중복되어 있을 경우를 조건으로 해서 로직을 짠다.

---

## 🗒️ 배운 점 & 느낀 점  
- `Counter().most_common()`를 이용하면 효율적으로 셀 수 있다.
- 처음에는 index와 전체를 비교하게 코드를 만들었으나, 자체적으로 정렬이 되어있으므로, 1번째와 2번째 값만 보면 된다.
- 효율적으로 코드를 짜는 안목이 늘어났다고 할 수 있다. 
---

## ⏱️ 시간복잡도 분석  
- 문자열 길이를 N이라 하면  
- 대문자 변환: O(N)  
- 빈도 계산: O(N)  
- 최댓값 판단: O(1) ~ O(26)  
- 전체 시간복잡도: **O(N)**

---
# 📌 백준 1316 - 그룹 단어 체커

## 🔗 링크  
[문제 링크](https://www.acmicpc.net/problem/1316)

---

## 📋 문제 설명  
- 단어 N개가 주어진다.  
- 각 단어가 **그룹 단어**인지 판단하여, 그룹 단어의 개수를 출력하는 문제이다.  
- 그룹 단어란, **같은 문자가 연속해서 나타나는 경우는 허용**하지만  
  **중간에 다른 문자가 끼어들고 다시 나타나면 그룹 단어가 아니다.**

---

## 🧠 알고리즘 분류  
- 문자열  
- 구현

---

## ✅ 핵심 포인트 정리  
- 문자를 순회하며 이전 문자와 다를 때마다 이미 등장한 문자인지 확인  
- 이미 등장한 문자가 다시 나오면 그룹 단어가 아니다.  
- 등장 여부 확인은 **set** 또는 **list**로 구현할 수 있다.  
- `prev_char`를 이용해 연속 문자 판단

---

## 🗒️ 배운 점 & 느낀 점  
- 조건이 단순해 보이지만 인덱스 관리나 중복 검사에 주의가 필요하다.  
- `set`을 사용하면 중복 문자 체크에 더 효율적이다.  
- 전에 나온 알파벳과, 사용되었던 알파벳 2가지 변수를 적절히 활용해서 논리적인 로직을 만드는 점이 굉장히 흥미로웠다.

---

## ⏱️ 시간복잡도 분석  
- 문자열 하나당 길이만큼 순회 → O(L)  
- 전체 단어 수가 N일 때 → **O(N × L)**  
  (L은 단어 평균 길이, N은 단어 개수)

---
