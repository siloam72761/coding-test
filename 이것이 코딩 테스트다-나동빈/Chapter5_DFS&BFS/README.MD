# 5-8 DFS 예제

## ✅ 핵심 아이디어
2차원 리스트로 각 노드가 연결된 정보를 표현한다. graph[[]]
방문 처리 처리된 걸 관리하는 변수를 visited로 관리한다.

## 🧠 배운점
visited[v] = True를 재귀 호출 전에 해줘야 루프에 빠지지 않는다.
DFS는 “깊게 들어가고, 막히면 되돌아온다(백트래킹)

## ⏱️ 복잡도
시간 복잡도는 O(V + E) 
V: 정점(노드) 수, E: 간선(연결) 수

# 5-9 BFS 예제

## ✅ 핵심 아이디어
deque를 이용해서 선입선출를 활용한다.
인접한 노드의 낮은 번호부터 deque에 넣고 순서대로 처리하며 그래프를 순회한다.

## 🧠 배운점
queue = deque(start) 형태로 사용하였으나, start가 반복 가능한 iterable 타입이 아니라서 에러.
queue = deque([start])의 형태로 사용해야 올바르게 작동한다.
BFS는 DFS보다 일반적으로 수행 시간이 더 빠르며 DFS 보다 더 빠르다.

## ⏱️ 복잡도
O(N)의 시간이 소요.

# 5-10 음료수 얼려 먹기

## ✅ 핵심 아이디어
2차원 리스트로 각 노드가 연결된 정보를 표현한다. 
주위에 인접해 있는 땅을 체크하기 위해 상하좌우를 재귀적으로 탐색한다.

## 🧠 배운점
dfs()함수가 다 돌았을 때 반환 값을 True로 받을 때 cnt를 해서
주변 땅을 다 탐색한 뒤에 1개씩 카운팅 하게 된다.

## ⏱️ 복잡도
모든 칸 방문은 O(N * M)
상화좌우는 O(4 N * M ) -> 즉 O(N*M)

# 5-11 미로 탈출

## ✅ 핵심 아이디어
BFS는 시작 지점에서 가까운 노드부터 차례대로 탐색하므로 미로 탐색에 유용하다.
(1,1)에서부터 (n-1,m-1)까지의 진행되는 노드 값을 더하면서 진행하면 최소 값이 된다.

## 🧠 배운점
앞으로 진행이 가능할 때마다 기존 좌표에서 1을 더한 값을 넣으면서 진행해간다.

## ⏱️ 복잡도
(격자에서 최단거리) 시간복잡도는 O(N * M)