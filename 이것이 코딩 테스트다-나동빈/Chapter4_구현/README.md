# 4-1 상화좌우

## ✅ 핵심 아이디어
1. 상하좌우를 좌표로 표현 mx, my
2. Boundary 체크

## 🧠 배운 점
1. 이동 후 좌표를 계산을 한 변수가 있었으면 코드가 훨씬 단순화가 가능했다.

## ⏱️ 복잡도
1. 이동 횟수가 N번인 경우 시간 복잡도는 \*\*O(N)\*\*이다.

# 4-2 시각

## ✅ 핵심 아이디어
1. 시간, 분, 초로 for문으로 표현한다.
2. 시간, 분, 초를 str으로 합쳐서 '3'이 있는지 체크한다.

## 🧠 배운점
1. 시간, 분, 초에 대해서 각각 '3'이 있는지 계산하는게 아니라, 합쳐서 하면 훨씬 빠르게 구현 가능하다.

## ⏱️ 복잡도
최대 실행횟수가 86,400개이기 때문에 O(1)이라고 할 수 있다.

# 4-3 왕실나이트

## ✅ 핵심 아이디어
1. 문자열 + 숫자 조합이 나올 때 문자열을 숫자로 변환하는 작업을 ord()을 이용한다.
2. 나이트의 움직임 경우의 수를 좌표로 표현한다.

## 🧠 배운점
1. ord(문자)
하나의 문자를 인자로 받고 해당 문자에 해당하는 유니코드 정수를 반환합니다.

2. chr(정수)
하나의 정수를 인자로 받고 해당 정수에 해당하는 유니코드 문자를 반환합니다.

## ⏱️ 복잡도
나이트의 움직임도 8개이기 때문에 시간 복잡도는 O(1)이다.

# 4-4 게임 개발

## ✅ 핵심 아이디어
1. 방문 했는지 체크하는 배열 + 4방향을 체크했는지 저장하는 변수가 필요하다.
2. 이동하는 방향은 dx,dy의 좌표로 계산하고 dir 변수로 방향의 상태를 저장한다.

## 🧠 배운점
1. 방향을 왼쪽 방향으로 하는 과정에서 -1씩 진행할 때 북에서 서가 될 경우 -1이 되는데 이를 dir[3]으로 예외 처리를 해준다.
2. 배열 형태의 입력을 [list(map(int, input().split())) for _ in range(N)]의 형태로 한 번에 처리한다.

## ⏱️ 복잡도
모든 경우의 수를 생각했을 때 최악의 경우 O(N*M)의 시간이 든다.