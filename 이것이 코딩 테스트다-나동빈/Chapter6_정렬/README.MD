# 6-1 선택정렬

## ✅ 핵심 아이디어
가장 작은 값을 0번째부터 시작하면서 N-1 반복해 정렬을 완료한다.
파이썬에서는 두 리스트 안의 원소를 간단히 swap 가능하다.

## 🧠 배운점
선택 정렬 시 n번씩 증가할 때 마다 관리할 수 있는 index를 사용한다.

## ⏱️ 복잡도
이중 for문이므로 시간 복잡도는 O(N^2)

# 6-3 삽입정렬

## ✅ 핵심 아이디어
선택 정렬에 비해서 실행 시간 측면에서 더 효율이 있다.
필요할 때만 위치를 바꾸기 때문에, 정렬이 되어 있으면 효과적이다.
데이터를 하나씩 확인하면서, 각 원소를 적절한 위치에 삽입한다.

## 🧠 배운점
한 칸씩 왼쪽으로 이동하면서 삽입 위치를 찾는다. 
array[j] < array[j-1] 이면 원소 스왑 한칸 왼쪽으로 이동 

## ⏱️ 복잡도
이중 for문이므로 시간 복잡도는 O(N^2)
정렬이 되어 있을 경우 O(N)으로 작동한다. (정렬 되어 있을 경우 퀵 정렬보다도 더 강력)

# 6-10 위에서 아래로

## ✅ 핵심 아이디어
정렬 라이브러리를 사용하는데, 어떻게 역순으로 정렬할 것인가가 핵심이다.
sorted을 쓰는법과, 리스트의 내장 함수 sort를 쓰는 방법이 있다.

## 🧠 배운점
sorted는 arr = sorted(array, reverse = True)의 형태로 사용
sort는 arr.sort(reverse=True)의 형태로 사용한다.

## ⏱️ 복잡도
시간 복잡도는 O(NlogN)이다.

# 6-11 성적이 낮은 순서로 학생 출력

## ✅ 핵심 아이디어
이름과 점수를 묶은 뒤에 정렬을 처리해야 한다.
람다를 이용해서 점수를 기준으로 정렬한다.

## 🧠 배운점
처음에는 딕셔너리로 풀었으나, 딕셔너리의 장점인 key 검색, 중복 방지, 빠른 조회를 안 쓰므로
이 문제는 사실상 리스트로 푸는게 더 적합하다.
d.items()라는 함수 자체가 리스트로 반환해주는 역할을 한다.


## ⏱️ 복잡도
시간 복잡도는 O(NlogN)이다.

# 6-12 두 배열의 원소 교체

## ✅ 핵심 아이디어
두 원소를 정렬하지만, 한 쪽은 역순으로 정렬해야 두 원소를 같은 조건문으로 스왑을 진행한다.
sort(reverse = True)로 내림차순으로 정렬한다.

## 🧠 배운점
리스트를 한꺼번에 합을 제공하는 sum()함수를 구현하면, 직접 for문으로 변수로 저장할 필요 없다.

## ⏱️ 복잡도
시간 복잡도는 O(NlogN)이다.